import{get_request_store as w,with_request_store as x}from"@sveltejs/kit/internal/server";import{parse as B}from"devalue";import{error as q,json as H}from"@sveltejs/kit";import{a as O,f as I,b as J,n as S,e as N,g as A,s as L,c as M}from"./chunks/shared.js";import{ValidationError as V}from"@sveltejs/kit/internal";import{B as z}from"./chunks/false.js";import{b as D,c as F}from"./chunks/server.js";import{p as T}from"./chunks/environment.js";function k(t,o){if(!o)return e=>{e!==void 0&&q(400,"Bad Request")};if(t==="unchecked")return e=>e;if("~standard"in t)return async e=>{const{event:r,state:s}=w(),u=await t["~standard"].validate(e);return u.issues&&q(400,await s.handleValidationError({issues:u.issues,event:r})),u.value};throw new Error('Invalid validator passed to remote function. Expected "unchecked" or a Standard Schema (https://standardschema.dev)')}async function $(t,o,e,r){await 0;const s=v(t,e);return s[O(o,e.transport)]??=r()}function G(t,o){const e={};for(const r in o)e[r]=o[r].decode;return B(t,e)}async function _(t,o,e,r,s,u){const i={event:{...t,setHeaders:()=>{throw new Error("setHeaders is not allowed in remote functions")},cookies:{...t.cookies,set:(c,f,l)=>{if(!e)throw new Error("Cannot set cookies in `query` or `prerender` functions");if(l.path&&!l.path.startsWith("/"))throw new Error("Cookies set in remote functions must have an absolute path");return t.cookies.set(c,f,l)},delete:(c,f)=>{if(!e)throw new Error("Cannot delete cookies in `query` or `prerender` functions");if(f.path&&!f.path.startsWith("/"))throw new Error("Cookies deleted in remote functions must have an absolute path");return t.cookies.delete(c,f)}}},state:{...o,is_in_remote_function:!0}},n=await x(i,()=>s(r));return x(i,()=>u(n))}function v(t,o=w().state){let e=o.remote_data?.get(t);return e===void 0&&(e={},(o.remote_data??=new Map).set(t,e)),e}function ie(t,o){const e=o??t,r=k(t,o),s={type:"command",id:"",name:""},u=i=>{const{event:n,state:c}=w();if(c.is_endpoint_request){if(!["POST","PUT","PATCH","DELETE"].includes(n.request.method))throw new Error(`Cannot call a command (\`${s.name}(${o?"...":""})\`) from a ${n.request.method} handler`)}else if(!n.isRemoteRequest)throw new Error(`Cannot call a command (\`${s.name}(${o?"...":""})\`) during server-side rendering`);c.refreshes??={};const f=Promise.resolve(_(n,c,!0,i,r,e));return f.updates=()=>{throw new Error(`Cannot call '${s.name}(...).updates(...)' on the server`)},f};return Object.defineProperty(u,"__",{value:s}),Object.defineProperty(u,"pending",{get:()=>0}),u}function ae(t,o){const e=o??t,r=!o||t==="unchecked"?null:t;function s(u){const i={};i.method="POST",Object.defineProperty(i,"enhance",{value:()=>({action:i.action,method:i.method})});const n={type:"form",name:"",id:"",fn:async(c,f,l)=>{const a={};a.submission=!0;const{event:d,state:m}=w(),h=await r?.["~standard"].validate(c);if(f.validate_only)return h?.issues?.map(y=>S(y,!0))??[];if(h?.issues!==void 0)R(a,h.issues,l);else{h!==void 0&&(c=h.value),m.refreshes??={};const y=K();try{a.result=await _(d,m,!0,c,p=>p,p=>o?e(p,y):e())}catch(p){if(p instanceof V)R(a,p.issues,l);else throw p}}return d.isRemoteRequest||(v(n,m)[""]??=a),a}};return Object.defineProperty(i,"__",{value:n}),Object.defineProperty(i,"action",{get:()=>`?/remote=${n.id}`,enumerable:!0}),Object.defineProperty(i,"fields",{get(){const c=v(n)?.[""],f=I(c?.issues??[]);return J({},()=>c?.input??{},(l,a)=>{if(c?.submission)return;const d=l.length===0?a:A(c?.input??{},l.map(String),a);(v(n)[""]??={}).input=d},()=>f)}}),Object.defineProperty(i,"result",{get(){try{return v(n)?.[""]?.result}catch{return}}}),Object.defineProperty(i,"pending",{get:()=>0}),Object.defineProperty(i,"preflight",{value:()=>i}),Object.defineProperty(i,"validate",{value:()=>{throw new Error("Cannot call validate() on the server")}}),u==null&&Object.defineProperty(i,"for",{value:c=>{const{state:f}=w(),l=n.id+"|"+JSON.stringify(c);let a=(f.form_instances??=new Map).get(l);return a||(a=s(c),a.__.id=`${n.id}/${encodeURIComponent(JSON.stringify(c))}`,a.__.name=n.name,f.form_instances.set(l,a)),a}}),i}return s()}function R(t,o,e){if(t.issues=o.map(r=>S(r,!0)),e){t.input={};for(let r of e.keys()){if(/^[.\]]?_/.test(r))continue;const s=r.endsWith("[]"),u=e.getAll(r).filter(i=>typeof i=="string");s&&(r=r.slice(0,-2)),N(t.input,r,s?u:u[0])}}}function K(){return new Proxy(e=>{if(typeof e!="string")throw new Error("`invalid` should now be imported from `@sveltejs/kit` to throw validation issues. The second parameter provided to the form function (renamed to `issue`) is still used to construct issues, e.g. `invalid(issue.field('message'))`. For more info see https://github.com/sveltejs/kit/pulls/14768");return t(e)},{get(e,r){return typeof r=="symbol"?e[r]:o(r,[])}});function t(e,r=[]){return{message:e,path:r}}function o(e,r){const s=[...r,e],u=i=>t(i,s);return new Proxy(u,{get(i,n){return typeof n=="symbol"?i[n]:/^\d+$/.test(n)?o(parseInt(n,10),s):o(n,s)}})}}function ce(t,o,e){const r=typeof o=="function"?o:void 0,s=e??(r?void 0:o),u=r??t,i=k(t,r),n={type:"prerender",id:"",name:"",has_arg:!!r,inputs:s?.inputs,dynamic:s?.dynamic},c=f=>{const l=(async()=>{const{event:a,state:d}=w(),m=O(f,d.transport),h=n.id,y=`${D}/${F}/remote/${h}${m?`/${m}`:""}`;if(!d.prerendering&&!z&&!a.isRemoteRequest)try{return await $(n,f,d,async()=>{const b=O(f,d.transport),U=v(n,d),W=U[b]??=fetch(new URL(y,a.url.origin).href).then(async C=>{if(!C.ok)throw new Error("Prerendered response not found");const P=await C.json();return P.type==="error"&&q(P.status,P.error),P.result});return G(await W,d.transport)})}catch{}if(d.prerendering?.remote_responses.has(y))return d.prerendering.remote_responses.get(y);const p=$(n,f,d,()=>_(a,d,!1,f,i,u));d.prerendering&&d.prerendering.remote_responses.set(y,p);const g=await p;if(d.prerendering){const b={type:"result",result:L(g,d.transport)};d.prerendering.dependencies.set(y,{body:JSON.stringify(b),response:H(b)})}return g})();return l.catch(()=>{}),l};return Object.defineProperty(c,"__",{value:n}),c}function Q(t,o){const e=o??t,r=k(t,o),s={type:"query",id:"",name:""},u=i=>{if(T)throw new Error(`Cannot call query '${s.name}' while prerendering, as prerendered pages need static data. Use 'prerender' from $app/server instead`);const{event:n,state:c}=w(),f=()=>_(n,c,!1,i,r,e),l=$(s,i,c,f);return l.catch(()=>{}),l.set=a=>j(E(s,"set",i),a),l.refresh=()=>{const a=E(s,"refresh",i),d=!a.cache[a.cache_key],m=d?l:f();return j(a,m,d)},l.withOverride=()=>{throw new Error(`Cannot call '${s.name}.withOverride()' on the server`)},l};return Object.defineProperty(u,"__",{value:s}),u}function X(t,o){const e=o??t,r=k(t,o),s={type:"query_batch",id:"",name:"",run:n=>{const{event:c,state:f}=w();return _(c,f,!1,n,l=>Promise.all(l.map(r)),e)}};let u={args:[],resolvers:[]};const i=n=>{if(T)throw new Error(`Cannot call query.batch '${s.name}' while prerendering, as prerendered pages need static data. Use 'prerender' from $app/server instead`);const{event:c,state:f}=w(),l=()=>new Promise((d,m)=>{u.args.push(n),u.resolvers.push({resolve:d,reject:m}),!(u.args.length>1)&&setTimeout(async()=>{const h=u;u={args:[],resolvers:[]};try{const y=await _(c,f,!1,h.args,p=>Promise.all(p.map(r)),e);for(let p=0;p<h.resolvers.length;p++)try{h.resolvers[p].resolve(y(h.args[p],p))}catch(g){h.resolvers[p].reject(g)}}catch(y){for(const p of h.resolvers)p.reject(y)}},0)}),a=$(s,n,f,l);return a.catch(()=>{}),a.set=d=>j(E(s,"set",n),d),a.refresh=()=>{const d=E(s,"refresh",n),m=!d.cache[d.cache_key],h=m?a:l();return j(d,h,m)},a.withOverride=()=>{throw new Error(`Cannot call '${s.name}.withOverride()' on the server`)},a};return Object.defineProperty(i,"__",{value:s}),i}Object.defineProperty(Q,"batch",{value:X,enumerable:!0});function E(t,o,e){const{state:r}=w(),{refreshes:s}=r;if(!s){const c=t.type==="query_batch"?`query.batch '${t.name}'`:`query '${t.name}'`;throw new Error(`Cannot call ${o} on ${c} because it is not executed in the context of a command/form remote function`)}const u=v(t,r),i=O(e,r.transport),n=M(t.id,i);return{__:t,state:r,refreshes:s,refreshes_key:n,cache:u,cache_key:i}}function j({__:t,refreshes:o,refreshes_key:e,cache:r,cache_key:s},u,i=!1){const n=Promise.resolve(u);return i||(r[s]=n),t.id&&(o[e]=n),n.then(()=>{})}export{ie as command,ae as form,ce as prerender,Q as query};
